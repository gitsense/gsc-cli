{
  "schema_version": "1.0",
  "generated_at": "2026-02-11T06:35:13.856Z",
  "manifest": {
    "name": "GitSense Chat CLI Architect",
    "database_name": "gsc-architect",
    "description": "Architectural mapping of the gsc-cli repository covering 68 files to build an intelligence layer for AI agents. This manifest tracks layers, public APIs, intent triggers, and dependencies to enable zero-shot discovery and automated decision-making within the codebase.",
    "tags": [
      "architecture",
      "gsc-cli",
      "go",
      "agent-discovery",
      "metadata"
    ]
  },
  "repositories": [
    {
      "ref": "R0",
      "name": "gitsense/gsc-cli"
    }
  ],
  "branches": [
    {
      "ref": "B0",
      "name": "main"
    }
  ],
  "analyzers": [
    {
      "ref": "A0",
      "id": "gsc-architect::file-content::default",
      "name": "GSC Lead Architect",
      "description": "Extracts high-signal architectural metadata (layers, APIs, intent triggers) to create an intelligence layer for the gsc-cli repository.",
      "version": "1.0.0"
    }
  ],
  "fields": [
    {
      "ref": "F0",
      "name": "layer",
      "type": "string",
      "display_name": "Layer",
      "description": "One of `cli`, `internal-logic`, `data-access`, `pkg-util`, or `config`. Assigned using the non-negotiable rules in ARCHITECTURE.md Section 6.",
      "analyzer_ref": "A0"
    },
    {
      "ref": "F1",
      "name": "purpose",
      "type": "string",
      "display_name": "Purpose",
      "description": "A refined, high-level explanation of why this file exists, building upon the generic purpose from PROJECT_MAP.md.",
      "analyzer_ref": "A0"
    },
    {
      "ref": "F2",
      "name": "technical_summary",
      "type": "string",
      "display_name": "Technical Summary",
      "description": "2-4 sentences explaining the implementation, mentioning key internal logic and primary method names.",
      "analyzer_ref": "A0"
    },
    {
      "ref": "F3",
      "name": "public_api",
      "type": "array",
      "display_name": "Public Api",
      "description": "List all exported functions, methods, structs, and interfaces. This is critical for zero-shot agentic discovery. Return empty array `[]` if no public API exists.",
      "analyzer_ref": "A0"
    },
    {
      "ref": "F4",
      "name": "intent_triggers",
      "type": "array",
      "display_name": "Intent Triggers",
      "description": "3-5 natural language phrases that should lead a user or agent to this file (e.g., \"how to open sqlite\", \"validate bridge code\").",
      "analyzer_ref": "A0"
    },
    {
      "ref": "F5",
      "name": "dependencies",
      "type": "array",
      "display_name": "Dependencies",
      "description": "List internal packages or critical files this file imports/relies on. Exclude standard library and external third-party packages.",
      "analyzer_ref": "A0"
    },
    {
      "ref": "F6",
      "name": "topics",
      "type": "array",
      "display_name": "Topics",
      "description": "Specific feature tags from the controlled vocabulary in ARCHITECTURE.md Section 4. Use ONLY the defined topics. Do not invent new ones.",
      "analyzer_ref": "A0"
    },
    {
      "ref": "F7",
      "name": "parent_topics",
      "type": "array",
      "display_name": "Parent Topics",
      "description": "Broad categories from the controlled vocabulary (e.g., `discovery`, `persistence`, `search`, `infrastructure`).",
      "analyzer_ref": "A0"
    }
  ],
  "data": [
    {
      "repo_ref": "R0",
      "branch_ref": "B0",
      "file_path": "pkg/settings/settings.go",
      "language": "go",
      "chat_id": 6467,
      "fields": {
        "F0": "config",
        "F1": "Centralizes global configuration constants for the application, defining default paths, file extensions, backup policies, and CLI Bridge parameters.",
        "F2": "Exports constants for directory names (.gitsense, backups), file extensions (.db, .json), and operational limits (MaxBackups, DefaultMaxBridgeSize). Includes variables for runtime overrides like GitSenseDir.",
        "F3": [
          "const DefaultGitSenseDir",
          "var GitSenseDir",
          "const RegistryFileName",
          "const DefaultDBExtension",
          "const ManifestJSONExtension",
          "const BackupsDir",
          "const TempDBSuffix",
          "const MaxBackups",
          "const DefaultMaxBridgeSize",
          "const BridgeCodeLength",
          "const RealModelNotes",
          "const BridgeHandshakeDir"
        ],
        "F4": [
          "Where are the default directory names defined?",
          "What is the maximum bridge output size?",
          "How many backups are retained by default?",
          "What is the file extension for manifest databases?"
        ],
        "F5": [],
        "F6": [
          "bridge",
          "manifest-management"
        ],
        "F7": [
          "infrastructure",
          "config"
        ]
      }
    },
    {
      "repo_ref": "R0",
      "branch_ref": "B0",
      "file_path": "pkg/logger/logger.go",
      "language": "go",
      "chat_id": 6469,
      "fields": {
        "F0": "pkg-util",
        "F1": "Provides a centralized, leveled logging system for the CLI, supporting color-coded output, structured key-value formatting, and configurable verbosity thresholds.",
        "F2": "Implements a global log level threshold (LevelError to LevelDebug) to control output verbosity. Functions like Info, Warning, Error, and Debug format messages with optional key-value pairs and ANSI color codes, writing to os.Stderr.",
        "F3": [
          "type Level int",
          "const LevelError",
          "const LevelWarning",
          "const LevelInfo",
          "const LevelDebug",
          "func SetLogLevel(level Level)",
          "func Info(message string, args ...interface{})",
          "func Success(message string, args ...interface{})",
          "func Warning(message string, args ...interface{})",
          "func Error(message string, args ...interface{})",
          "func Fatal(message string, args ...interface{})",
          "func Debug(message string, args ...interface{})"
        ],
        "F4": [
          "How do I enable debug logging in the CLI?",
          "Where is the logging utility defined?",
          "How do I print colored error messages?",
          "What is the default log level?"
        ],
        "F5": [],
        "F6": [],
        "F7": [
          "infrastructure"
        ]
      }
    },
    {
      "repo_ref": "R0",
      "branch_ref": "B0",
      "file_path": "internal/version/version.go",
      "language": "go",
      "chat_id": 6472,
      "fields": {
        "F0": "pkg-util",
        "F1": "Stores and retrieves version information, including the application version, Git commit hash, and build timestamp.",
        "F2": "Defines global variables populated by ldflags at build time and provides a formatted string getter for version display.",
        "F3": [
          "Version",
          "GitCommit",
          "BuildTime",
          "GetVersion"
        ],
        "F4": [
          "How do I get the current version of the CLI?",
          "Where is the Git commit hash stored?",
          "What is the build timestamp of the binary?"
        ],
        "F5": [],
        "F6": [
          "infrastructure"
        ],
        "F7": [
          "infrastructure"
        ]
      }
    },
    {
      "repo_ref": "R0",
      "branch_ref": "B0",
      "file_path": "internal/search/aggregator.go",
      "language": "go",
      "chat_id": 6474,
      "fields": {
        "F0": "internal-logic",
        "F1": "Transforms raw enriched search matches into a structured summary, grouping by file, calculating statistics, and applying truncation limits.",
        "F2": "Implements AggregateMatches to process MatchResult slices. It groups matches by file path, calculates match counts, aggregates categorical metadata fields into a distribution map, sorts files by relevance (match count), and applies a truncation limit to the final output.",
        "F3": [
          "func AggregateMatches(matches []MatchResult, limit int) GrepSummary"
        ],
        "F4": [
          "How are search results grouped and summarized?",
          "Where is the logic for truncating search output?",
          "How does the CLI calculate statistics on search matches?",
          "What determines the order of files in search results?"
        ],
        "F5": [
          "internal/search/models.go"
        ],
        "F6": [
          "ripgrep",
          "metadata-enrichment"
        ],
        "F7": [
          "search"
        ]
      }
    },
    {
      "repo_ref": "R0",
      "branch_ref": "B0",
      "file_path": "internal/search/engine.go",
      "language": "go",
      "chat_id": 6475,
      "fields": {
        "F0": "internal-logic",
        "F1": "Defines the core abstraction for search engines, allowing pluggable implementations like ripgrep, and structures raw search results for further enrichment.",
        "F2": "Defines the SearchEngine interface and associated structs (SearchOptions, RawMatch, SearchResult) to decouple the search execution logic from the enrichment and formatting layers. It provides the contract that concrete implementations like RipgrepEngine must fulfill.",
        "F3": [
          "SearchEngine",
          "SearchOptions",
          "RawMatch",
          "SearchResult"
        ],
        "F4": [
          "What is the interface for implementing a new search engine?",
          "How are raw search results structured before enrichment?",
          "Where is the SearchEngine interface defined?",
          "What data structures are used to pass search options?"
        ],
        "F5": [],
        "F6": [
          "ripgrep"
        ],
        "F7": [
          "search",
          "infrastructure"
        ]
      }
    },
    {
      "repo_ref": "R0",
      "branch_ref": "B0",
      "file_path": "internal/search/enricher.go",
      "language": "go",
      "chat_id": 6476,
      "fields": {
        "F0": "internal-logic",
        "F1": "Orchestrates the enrichment of raw search matches by fetching metadata from SQLite, applying system and metadata filters, and projecting requested fields for the final result set.",
        "F2": "Implements EnrichMatches to perform batch lookups against the manifest database using fetchMetadataMap. It applies FilterCondition logic, handles array vs scalar field comparisons, and prunes fields based on user requests to generate the final MatchResult list.",
        "F3": [
          "EnrichMatches",
          "FetchMetadataMap",
          "FileMetadata"
        ],
        "F4": [
          "How are search results enriched with metadata from the database?",
          "Where is the logic for filtering search results by metadata fields?",
          "How does the system handle array fields in metadata filters?",
          "What is the batch lookup strategy for file metadata?"
        ],
        "F5": [
          "internal/db",
          "internal/manifest",
          "pkg/logger"
        ],
        "F6": [
          "metadata-enrichment",
          "batch-metadata-lookup",
          "filter-parsing-and-validation"
        ],
        "F7": [
          "search",
          "persistence"
        ]
      }
    },
    {
      "repo_ref": "R0",
      "branch_ref": "B0",
      "file_path": "internal/search/formatter.go",
      "language": "go",
      "chat_id": 6477,
      "fields": {
        "F0": "internal-logic",
        "F1": "Handles the formatting and presentation of search results, supporting both human-readable terminal output with syntax highlighting and structured JSON for the CLI Bridge.",
        "F2": "Implements FormatResponse and FormatResponseToString to convert MatchResult data into JSON or colored terminal output. It groups matches by file, applies syntax highlighting using logger utilities, and handles metadata projection and field filtering.",
        "F3": [
          "FormatResponse",
          "FormatResponseToString",
          "GroupMatchesByFile",
          "FormatOptions"
        ],
        "F4": [
          "How are search results formatted for the terminal?",
          "Where is the JSON output generated for the CLI Bridge?",
          "How does the CLI highlight search matches and metadata?",
          "How are search matches grouped by file for display?"
        ],
        "F5": [
          "internal/output",
          "pkg/logger"
        ],
        "F6": [
          "bridge",
          "ripgrep"
        ],
        "F7": [
          "search",
          "infrastructure"
        ]
      }
    },
    {
      "repo_ref": "R0",
      "branch_ref": "B0",
      "file_path": "internal/search/models.go",
      "language": "go",
      "chat_id": 6478,
      "fields": {
        "F0": "internal-logic",
        "F1": "Defines the core data structures and JSON schemas for the search subsystem, including request contexts, result summaries, and filter conditions.",
        "F2": "Contains structs for GrepResponse, QueryContext, FileResult, and MatchDetail. Defines the JSON schema for agent communication and internal data passing between the engine, enricher, and aggregator.",
        "F3": [
          "GrepResponse",
          "QueryContext",
          "GrepSummary",
          "FileResult",
          "MatchDetail",
          "FilterCondition",
          "SearchRecord"
        ],
        "F4": [
          "What is the JSON structure of a search response?",
          "Where are the search result data models defined?",
          "How is filter condition structured in memory?",
          "What data is stored in the search history database?"
        ],
        "F5": [],
        "F6": [
          "search"
        ],
        "F7": [
          "infrastructure"
        ]
      }
    },
    {
      "repo_ref": "R0",
      "branch_ref": "B0",
      "file_path": "internal/search/ripgrep_engine.go",
      "language": "go",
      "chat_id": 6479,
      "fields": {
        "F0": "internal-logic",
        "F1": "Implements the SearchEngine interface using the ripgrep binary to perform high-performance code search and parse JSON output into structured results.",
        "F2": "Executes rg as a subprocess with context support. Parses streaming JSON output to reconstruct matches with context lines. Handles version detection and specific ripgrep exit codes.",
        "F3": [
          "RipgrepEngine",
          "Search"
        ],
        "F4": [
          "How does gsc execute the ripgrep binary?",
          "Where is the ripgrep JSON output parsed into Go structs?",
          "How are context lines extracted and associated with search matches?",
          "What implements the SearchEngine interface for code search?"
        ],
        "F5": [
          "pkg/logger",
          "internal/search/models"
        ],
        "F6": [
          "ripgrep"
        ],
        "F7": [
          "search"
        ]
      }
    },
    {
      "repo_ref": "R0",
      "branch_ref": "B0",
      "file_path": "internal/registry/models.go",
      "language": "go",
      "chat_id": 6481,
      "fields": {
        "F0": "data-access",
        "F1": "Defines the data structures (Registry, RegistryEntry) for the manifest registry and provides methods for in-memory manipulation (upsert, find, remove) of these entries.",
        "F2": "Defines Registry and RegistryEntry structs with JSON tags. Implements UpsertEntry to update or add entries by DatabaseName, FindEntry/FindEntryByDBName for lookups, and RemoveEntry methods.",
        "F3": [
          "Registry",
          "RegistryEntry",
          "NewRegistry",
          "UpsertEntry",
          "FindEntry",
          "FindEntryByDBName",
          "RemoveEntry",
          "RemoveEntryByDBName"
        ],
        "F4": [
          "What is the data structure for a registry entry?",
          "How does the registry distinguish between a display name and a database file?",
          "How do I look up a database by its physical name?",
          "What fields are stored in the manifest.json file?"
        ],
        "F5": [],
        "F6": [
          "manifest-management"
        ],
        "F7": [
          "persistence",
          "infrastructure"
        ]
      }
    },
    {
      "repo_ref": "R0",
      "branch_ref": "B0",
      "file_path": "internal/registry/registry.go",
      "language": "go",
      "chat_id": 6482,
      "fields": {
        "F0": "data-access",
        "F1": "Manages the persistence of the manifest registry file (manifest.json), handling loading, saving, and atomic upserts of database entries to ensure consistency.",
        "F2": "Implements LoadRegistry to read JSON from disk (creating a new one if missing), SaveRegistry to write indented JSON, and AddEntry which wraps an upsert operation to prevent duplicates. Uses git.FindProjectRoot to resolve paths.",
        "F3": [
          "LoadRegistry",
          "SaveRegistry",
          "AddEntry"
        ],
        "F4": [
          "How does gsc load the manifest registry file?",
          "Where is the manifest.json file physically located on disk?",
          "How are new databases registered in the system?",
          "What happens if the registry file is corrupted or missing?"
        ],
        "F5": [
          "internal/git",
          "pkg/logger",
          "pkg/settings"
        ],
        "F6": [
          "manifest-management"
        ],
        "F7": [
          "persistence",
          "infrastructure"
        ]
      }
    },
    {
      "repo_ref": "R0",
      "branch_ref": "B0",
      "file_path": "internal/output/formatter.go",
      "language": "go",
      "chat_id": 6484,
      "fields": {
        "F0": "pkg-util",
        "F1": "Provides utility functions to format data into JSON, Table, or CSV strings and constructs Markdown messages for the CLI Bridge.",
        "F2": "Implements string builders for table alignment, CSV writers, JSON marshaling, and TTY detection. Includes specific logic for the CLI Bridge Markdown wrapper.",
        "F3": [
          "FormatJSON",
          "FormatTable",
          "FormatCSV",
          "FormatDatabaseTable",
          "IsTerminal",
          "FormatBridgeMarkdown"
        ],
        "F4": [
          "How does the CLI format output as a table?",
          "Where is the Markdown wrapper for the CLI Bridge generated?",
          "How do I convert database results to CSV?",
          "How does the tool detect if output is going to a terminal?"
        ],
        "F5": [],
        "F6": [
          "bridge",
          "infrastructure"
        ],
        "F7": [
          "infrastructure"
        ]
      }
    },
    {
      "repo_ref": "R0",
      "branch_ref": "B0",
      "file_path": "internal/manifest/bundler.go",
      "language": "go",
      "chat_id": 6486,
      "fields": {
        "F0": "internal-logic",
        "F1": "Generates context bundles by executing SQL queries against a manifest database, formatting results into lists or JSON for use in chat sessions or other tools.",
        "F2": "Connects to SQLite via the db package, executes a user-provided SQL query, and dynamically scans rows into BundleFile structs. It validates database existence prior to connection and handles type conversion for SQLite int64 values. Output is formatted as either a text list or JSON.",
        "F3": [
          "CreateBundle",
          "BundleFile"
        ],
        "F4": [
          "How do I generate a list of files for a chat session?",
          "Where is the logic to execute custom SQL queries against manifests?",
          "How does the CLI Bridge receive file lists?",
          "How are context bundles formatted for export?"
        ],
        "F5": [
          "internal/db",
          "internal/manifest/path_helper",
          "pkg/logger"
        ],
        "F6": [
          "sqlite",
          "manifest-management"
        ],
        "F7": [
          "persistence",
          "infrastructure"
        ]
      }
    },
    {
      "repo_ref": "R0",
      "branch_ref": "B0",
      "file_path": "internal/manifest/config.go",
      "language": "go",
      "chat_id": 6487,
      "fields": {
        "F0": "internal-logic",
        "F1": "Manages the loading, saving, and merging of query configurations and profiles, handling scope resolution precedence and integrating project-level settings from .gitsense-map.",
        "F2": "Implements JSON persistence for QueryConfig and Profile structs. The GetEffectiveConfig function orchestrates a three-tier merge: Active Profile > Global Settings > .gitsense-map. It handles file I/O for configuration and profile directories within the .gitsense workspace.",
        "F3": [
          "LoadConfig",
          "SaveConfig",
          "GetEffectiveConfig",
          "LoadProfile",
          "SaveProfile",
          "NewQueryConfig",
          "SetDefault",
          "ClearDefault",
          "QueryConfig",
          "GlobalSettings",
          "QuerySettings",
          "RGSettings",
          "QueryAlias"
        ],
        "F4": [
          "How does the CLI resolve which Focus Scope to use?",
          "Where are context profiles stored and loaded?",
          "How do I merge project-level defaults with user settings?",
          "What is the precedence order for configuration values?"
        ],
        "F5": [
          "internal/git",
          "internal/manifest/gitsense_map",
          "pkg/logger",
          "pkg/settings"
        ],
        "F6": [
          "focus-scope",
          "profile-based-configuration",
          "scope-resolution-precedence"
        ],
        "F7": [
          "infrastructure",
          "configuration"
        ]
      }
    },
    {
      "repo_ref": "R0",
      "branch_ref": "B0",
      "file_path": "internal/manifest/doctor_logic.go",
      "language": "go",
      "chat_id": 6488,
      "fields": {
        "F0": "internal-logic",
        "F1": "Performs health checks on the `.gitsense` environment, validating the project root, directory structure, registry file, database connectivity, and identifying orphaned database files.",
        "F2": "Runs a series of diagnostic checks starting from the Git root down to individual database files. It verifies the existence and parse-ability of the registry, attempts to open connections to all registered databases to ensure integrity, and scans the directory for unregistered .db files to report orphans.",
        "F3": [
          "RunDoctor",
          "DoctorReport",
          "CheckResult"
        ],
        "F4": [
          "How do I check if my gsc environment is configured correctly?",
          "Why is the CLI failing to find my database?",
          "Are there any orphaned database files in my workspace?",
          "How can I diagnose connectivity issues with the manifest database?"
        ],
        "F5": [
          "internal/db",
          "internal/registry",
          "internal/git",
          "pkg/settings"
        ],
        "F6": [
          "manifest-management",
          "sqlite"
        ],
        "F7": [
          "infrastructure"
        ]
      }
    },
    {
      "repo_ref": "R0",
      "branch_ref": "B0",
      "file_path": "internal/manifest/exporter.go",
      "language": "go",
      "chat_id": 6489,
      "fields": {
        "F0": "internal-logic",
        "F1": "Exports the contents of a manifest database to human-readable formats (Markdown or JSON), validating database existence and retrieving all associated metadata, files, and references.",
        "F2": "Validates the target database exists, opens a connection, and executes a series of SELECT queries to fetch all tables (manifest_info, repositories, branches, files, etc.) into a unified ExportData struct. It then formats this struct into either a Markdown report or a JSON string based on user input.",
        "F3": [
          "ExportDatabase",
          "fetchExportData",
          "formatMarkdown",
          "formatJSON"
        ],
        "F4": [
          "How can I export my manifest data to a readable format?",
          "How do I view the raw contents of a specific manifest database?",
          "Can I generate a Markdown report of my repository intelligence?",
          "What is the schema structure of the manifest database?"
        ],
        "F5": [
          "internal/db"
        ],
        "F6": [
          "manifest-management",
          "sqlite"
        ],
        "F7": [
          "persistence"
        ]
      }
    },
    {
      "repo_ref": "R0",
      "branch_ref": "B0",
      "file_path": "internal/manifest/importer.go",
      "language": "go",
      "chat_id": 6490,
      "fields": {
        "F0": "internal-logic",
        "F1": "Handles the parsing and importing of JSON manifests into SQLite databases using an atomic swap strategy, including backup rotation, file locking, and language detection.",
        "F2": "Implements an atomic import workflow that reads JSON, validates structure, resolves database names, and writes data to a temporary SQLite file. It uses transactions to insert manifest info, references, and file metadata, handling array serialization. Finally, it backs up the existing database (if any) and performs an atomic file rename.",
        "F3": [
          "ImportManifest",
          "insertManifestInfo",
          "insertReferenceData",
          "insertFileData",
          "detectLanguage",
          "backupDatabase",
          "compressFile",
          "rotateBackups"
        ],
        "F4": [
          "How do I import a JSON manifest into the database?",
          "What happens if I import a database that already exists?",
          "How are database backups managed during imports?",
          "Where is the logic for detecting file languages?",
          "How does the system ensure data integrity during an import failure?"
        ],
        "F5": [
          "internal/db",
          "internal/registry",
          "internal/git",
          "pkg/settings",
          "pkg/logger"
        ],
        "F6": [
          "manifest-management",
          "atomic-import",
          "sqlite",
          "git-integration"
        ],
        "F7": [
          "persistence",
          "infrastructure"
        ]
      }
    },
    {
      "repo_ref": "R0",
      "branch_ref": "B0",
      "file_path": "internal/manifest/info.go",
      "language": "go",
      "chat_id": 6491,
      "fields": {
        "F0": "internal-logic",
        "F1": "Aggregates and formats workspace status information, displaying available databases and project context while internally managing hidden profile configurations.",
        "F2": "GetWorkspaceInfo collects project root, active profile (hidden), and database lists. FormatWorkspaceInfo handles output generation for JSON or table formats, explicitly suppressing profile details from the user view.",
        "F3": [
          "WorkspaceInfo",
          "GetWorkspaceInfo",
          "FormatWorkspaceInfo",
          "FormatWorkspaceHeader"
        ],
        "F4": [
          "How do I check which databases are available?",
          "What is the current status of the GitSense workspace?",
          "Where is the project root and GitSense directory located?",
          "Why are profiles not showing up in the info output?"
        ],
        "F5": [
          "internal/git",
          "internal/manifest/config",
          "internal/manifest/profile_manager",
          "internal/manifest/querier",
          "pkg/settings",
          "pkg/logger"
        ],
        "F6": [
          "manifest-management",
          "profile-based-configuration"
        ],
        "F7": [
          "discovery"
        ]
      }
    },
    {
      "repo_ref": "R0",
      "branch_ref": "B0",
      "file_path": "internal/manifest/initializer.go",
      "language": "go",
      "chat_id": 6492,
      "fields": {
        "F0": "internal-logic",
        "F1": "Initializes the `.gitsense` workspace environment by creating the directory structure, the manifest registry file, and the necessary `.gitignore` rules.",
        "F2": "The InitializeGitSense function locates the project root, creates the .gitsense directory, writes an empty manifest.json registry, and adds a .gitignore to exclude database files. It uses structured logging and handles idempotency checks.",
        "F3": [
          "InitializeGitSense"
        ],
        "F4": [
          "How does the CLI set up the initial workspace?",
          "Where is the manifest registry file created?",
          "What directory structure is required for GitSense?",
          "How are database files excluded from Git commits?"
        ],
        "F5": [
          "internal/git",
          "pkg/settings",
          "pkg/logger"
        ],
        "F6": [
          "manifest-management"
        ],
        "F7": [
          "infrastructure"
        ]
      }
    },
    {
      "repo_ref": "R0",
      "branch_ref": "B0",
      "file_path": "internal/manifest/models.go",
      "language": "go",
      "chat_id": 6493,
      "fields": {
        "F0": "internal-logic",
        "F1": "Defines the core Go data structures that map to the JSON manifest schema, representing the data model for repositories, branches, analyzers, and file metadata.",
        "F2": "Contains exported structs such as ManifestFile and DataEntry that mirror the JSON schema. DataEntry uses a map for flexible field storage to accommodate arbitrary analyzer outputs.",
        "F3": [
          "ManifestFile",
          "ManifestInfo",
          "Repository",
          "Branch",
          "Analyzer",
          "Field",
          "DataEntry"
        ],
        "F4": [
          "What is the Go structure for a manifest file?",
          "How are file metadata and custom fields represented in the system?",
          "Where are the analyzer definitions and field types stored?",
          "What data types are used for repository and branch references?"
        ],
        "F5": [],
        "F6": [
          "manifest-management"
        ],
        "F7": [
          "persistence"
        ]
      }
    },
    {
      "repo_ref": "R0",
      "branch_ref": "B0",
      "file_path": "internal/manifest/path_helper.go",
      "language": "go",
      "chat_id": 6494,
      "fields": {
        "F0": "internal-logic",
        "F1": "Helper functions to resolve file paths for databases, backups, locks, and manifests within the .gitsense directory.",
        "F2": "Provides path resolution utilities (ResolveDBPath, ResolveTempDBPath, ResolveBackupDir, ResolveLockPath) that locate the project root and construct absolute paths for workspace resources.",
        "F3": [
          "ResolveDBPath",
          "ResolveTempDBPath",
          "ResolveBackupDir",
          "ResolveLockPath",
          "ResolveJSONPath",
          "ValidateDBExists"
        ],
        "F4": [
          "Where are the SQLite database files stored?",
          "How do I get the path for the import lock file?",
          "Where are manifest backups located?"
        ],
        "F5": [
          "internal/git",
          "pkg/logger",
          "pkg/settings"
        ],
        "F6": [
          "infrastructure"
        ],
        "F7": [
          "infrastructure"
        ]
      }
    },
    {
      "repo_ref": "R0",
      "branch_ref": "B0",
      "file_path": "internal/manifest/profile_manager.go",
      "language": "go",
      "chat_id": 6495,
      "fields": {
        "F0": "internal-logic",
        "F1": "Manages the lifecycle of Context Profiles, including listing, creating, deleting, activating, and deactivating profiles.",
        "F2": "Implements CRUD operations for profiles stored as JSON files in .gitsense/profiles. Handles alias resolution, uniqueness validation, and updates the active profile state in the main configuration file.",
        "F3": [
          "ListProfiles",
          "CreateProfile",
          "DeleteProfile",
          "ShowProfile",
          "SetActiveProfile",
          "DeactivateProfile",
          "GetActiveProfileName",
          "ValidateAliasUniqueness",
          "ResolveProfile"
        ],
        "F4": [
          "How do I create or delete a context profile?",
          "How does the CLI resolve profile aliases?",
          "Where is the logic for switching active profiles located?"
        ],
        "F5": [
          "internal/git",
          "pkg/logger",
          "pkg/settings",
          "internal/manifest"
        ],
        "F6": [
          "profile-based-configuration"
        ],
        "F7": [
          "infrastructure"
        ]
      }
    },
    {
      "repo_ref": "R0",
      "branch_ref": "B0",
      "file_path": "internal/manifest/profile_models.go",
      "language": "go",
      "chat_id": 6496,
      "fields": {
        "F0": "internal-logic",
        "F1": "Defines the Go structs for Context Profiles, representing named workspaces with pre-defined configuration values, including support for Focus Scope.",
        "F2": "Defines Profile, ProfileSettings, GlobalSettings, QuerySettings, and RGSettings structs using JSON tags to serialize configuration for the internal profile system.",
        "F3": [
          "Profile",
          "ProfileSettings",
          "GlobalSettings",
          "QuerySettings",
          "RGSettings"
        ],
        "F4": [
          "What is the data structure for a context profile?",
          "How is the Focus Scope configuration stored in a profile?",
          "Where are the default settings for the gsc rg command defined?"
        ],
        "F5": [],
        "F6": [
          "profile-based-configuration",
          "focus-scope"
        ],
        "F7": [
          "infrastructure"
        ]
      }
    },
    {
      "repo_ref": "R0",
      "branch_ref": "B0",
      "file_path": "internal/manifest/querier.go",
      "language": "go",
      "chat_id": 6497,
      "fields": {
        "F0": "internal-logic",
        "F1": "Retrieves and summarizes registered manifest databases from the registry, including file counts and metadata tags.",
        "F2": "Implements ListDatabases which loads the registry, iterates over entries, opens each SQLite database to count files, and returns a summary list (DatabaseInfo). It bridges the registry and the physical database files.",
        "F3": [
          "ListDatabases",
          "DatabaseInfo"
        ],
        "F4": [
          "How does the CLI get the list of available databases?",
          "Where are the file counts for the database list calculated?",
          "How does the system resolve the physical path of a manifest database?",
          "What happens if a registered database file is missing?"
        ],
        "F5": [
          "internal/db",
          "internal/git",
          "internal/registry",
          "pkg/logger"
        ],
        "F6": [
          "manifest-management"
        ],
        "F7": [
          "discovery",
          "persistence"
        ]
      }
    },
    {
      "repo_ref": "R0",
      "branch_ref": "B0",
      "file_path": "internal/manifest/query_formatter.go",
      "language": "go",
      "chat_id": 6498,
      "fields": {
        "F0": "internal-logic",
        "F1": "Formats query results, discovery lists, coverage reports, and insights into JSON or human-readable tables, supporting hierarchical views for the intelligence map.",
        "F2": "Implements functions like FormatQueryResults, FormatListResult, FormatCoverageReport, and FormatInsightsReport. It uses internal/output for table generation and handles specific rendering logic for progress bars and hierarchical indentation.",
        "F3": [
          "FormatQueryResults",
          "FormatListResult",
          "FormatStatusView",
          "FormatCoverageReport",
          "FormatInsightsReport",
          "FormatReport"
        ],
        "F4": [
          "How does the CLI render the discovery dashboard?",
          "Where is the logic for the coverage report progress bars?",
          "How are query results converted to JSON?",
          "What determines the layout of the insights report?"
        ],
        "F5": [
          "internal/output",
          "internal/manifest/config"
        ],
        "F6": [
          "hierarchical-discovery"
        ],
        "F7": [
          "discovery"
        ]
      }
    },
    {
      "repo_ref": "R0",
      "branch_ref": "B0",
      "file_path": "internal/manifest/query_models.go",
      "language": "go",
      "chat_id": 6499,
      "fields": {
        "F0": "internal-logic",
        "F1": "Defines the core data structures for query operations, coverage analysis, and insights reporting, including hierarchical list items for the discovery dashboard.",
        "F2": "Contains Go structs like SimpleQuery, QueryResponse, ListResult, CoverageReport, and InsightsReport. It models the data flow for the gsc query subsystem, distinguishing between database slugs and labels.",
        "F3": [
          "SimpleQuery",
          "QueryResult",
          "QueryResponse",
          "QuerySummary",
          "ListResult",
          "ListItem",
          "QueryAlias",
          "CoverageReport",
          "CoverageTotals",
          "CoveragePercentages",
          "LanguageCoverage",
          "BlindSpots",
          "DirectoryBlindSpot",
          "InsightsReport",
          "InsightsContext",
          "FieldInsight",
          "InsightsSummary"
        ],
        "F4": [
          "What data structures are used for the query response?",
          "How is the coverage report modeled?",
          "Where is the definition for the hierarchical discovery list items?",
          "What fields are available in the insights report?"
        ],
        "F5": [],
        "F6": [
          "hierarchical-discovery",
          "metadata-enrichment"
        ],
        "F7": [
          "discovery",
          "persistence"
        ]
      }
    },
    {
      "repo_ref": "R0",
      "branch_ref": "B0",
      "file_path": "internal/manifest/rg_enricher.go",
      "language": "go",
      "chat_id": 6500,
      "fields": {
        "F0": "internal-logic",
        "F1": "Enriches raw ripgrep matches with metadata from the database, supporting both single-match and batch lookup workflows.",
        "F2": "Implements EnrichMatches for single-file lookups and GetMetadataForFiles for batch lookups using SQL IN clauses. Includes formatters for YAML/JSON metadata output.",
        "F3": [
          "EnrichMatches",
          "GetMetadataForFiles",
          "FormatMetadataYAML",
          "FormatMetadataJSON"
        ],
        "F4": [
          "How are search results enriched with metadata?",
          "Where is the batch metadata lookup logic located?",
          "How does the system handle files missing from the database?",
          "How is the metadata appendix formatted for output?"
        ],
        "F5": [
          "internal/db",
          "pkg/logger"
        ],
        "F6": [
          "ripgrep",
          "metadata-enrichment",
          "batch-metadata-lookup",
          "sqlite"
        ],
        "F7": [
          "search",
          "persistence"
        ]
      }
    },
    {
      "repo_ref": "R0",
      "branch_ref": "B0",
      "file_path": "internal/manifest/rg_executor.go",
      "language": "go",
      "chat_id": 6501,
      "fields": {
        "F0": "internal-logic",
        "F1": "Executes ripgrep as a subprocess, supporting both JSON discovery passes and raw display passes for the dual-pass workflow.",
        "F2": "Implements ExecuteRipgrep for JSON parsing and ExecuteRipgrepRaw for colored terminal output. Handles argument construction, subprocess management,fortable JSON stream parsing.",
        "F3": [
          "ExecuteRipgrep",
          "ExecuteRipgrepRaw"
        ],
        "F4": [
          "How does gsc execute the ripgrep binary?",
          "Where is the dual-pass search logic implemented?",
          "How are ripgrep command-line arguments constructed?",
          "How does the tool handle ripgrep not being installed?"
        ],
        "F5": [
          "pkg/logger"
        ],
        "F6": [
          "ripgrep",
          "dual-pass-search"
        ],
        "F7": [
          "search",
          "infrastructure"
        ]
      }
    },
    {
      "repo_ref": "R0",
      "branch_ref": "B0",
      "file_path": "internal/manifest/rg_models.go",
      "language": "go",
      "chat_id": 6502,
      "fields": {
        "F0": "internal-logic",
        "F1": "Defines the Go structs for ripgrep operations, including raw matches, enriched results, and the new FileMetadataResult struct for the YAML/JSON appendix.",
        "F2": "Defines RgMatch for raw ripgrep JSON output, EnrichedMatch for database-enriched results, RgOptions for configuration, and FileMetadataResult for batch metadata lookups.",
        "F3": [
          "RgMatch",
          "EnrichedMatch",
          "RgOptions",
          "FileMetadataResult"
        ],
        "F4": [
          "What is the data structure for a ripgrep match?",
          "How is enriched search data represented?",
          "Where are the configuration options for the search command defined?",
          "What fields are available in the metadata appendix?"
        ],
        "F5": [],
        "F6": [
          "ripgrep",
          "metadata-enrichment"
        ],
        "F7": [
          "search",
          "discovery"
        ]
      }
    },
    {
      "repo_ref": "R0",
      "branch_ref": "B0",
      "file_path": "internal/manifest/schemareader.go",
      "language": "go",
      "chat_id": 6503,
      "fields": {
        "F0": "internal-logic",
        "F1": "Retrieves and structures schema definitions (analyzers and fields) from the manifest database to support introspection and query validation.",
        "F2": "Implements GetSchema to fetch analyzer and field definitions, ListFieldNames for UI helpers, and GetFieldTypes to provide type information for the filter parser.",
        "F3": [
          "GetSchema",
          "ListFieldNames",
          "GetFieldTypes"
        ],
        "F4": [
          "How can I retrieve the schema definition for a specific manifest database?",
          "Where does the CLI get the list of available fields for the wizard?",
          "How does the filter parser know if a field is an array or a string?",
          "What analyzers are defined in the current database?"
        ],
        "F5": [
          "internal/db",
          "pkg/logger"
        ],
        "F6": [
          "sqlite",
          "manifest-management"
        ],
        "F7": [
          "discovery",
          "persistence"
        ]
      }
    },
    {
      "repo_ref": "R0",
      "branch_ref": "B0",
      "file_path": "internal/manifest/simple_querier.go",
      "language": "go",
      "chat_id": 6504,
      "fields": {
        "F0": "internal-logic",
        "F1": "Executes metadata queries and hierarchical discovery operations, including coverage analysis and insights aggregation, while respecting focus scope constraints.",
        "F2": "Provides ExecuteSimpleQuery for value matching, GetListResult for hierarchical drill-down, and PrepareTargetSet for scope-aware filtering. Includes ExecuteCoverageAnalysis for blind spot detection and ExecuteInsightsAnalysis for metadata aggregation.",
        "F3": [
          "ExecuteSimpleQuery",
          "GetListResult",
          "ExecuteCoverageAnalysis",
          "ExecuteInsightsAnalysis"
        ],
        "F4": [
          "How do I query files by a specific metadata value?",
          "Where is the logic for the hierarchical discovery dashboard (DB -> Field -> Value)?",
          "How does the coverage analysis feature calculate blind spots?",
          "How are insights and statistics aggregated from the manifest database?",
          "How does the system handle searching inside array-type metadata fields?"
        ],
        "F5": [
          "internal/db",
          "internal/git",
          "pkg/logger"
        ],
        "F6": [
          "sqlite",
          "focus-scope",
          "hierarchical-discovery",
          "batch-metadata-lookup"
        ],
        "F7": [
          "discovery",
          "persistence"
        ]
      }
    },
    {
      "repo_ref": "R0",
      "branch_ref": "B0",
      "file_path": "internal/manifest/validator.go",
      "language": "go",
      "chat_id": 6505,
      "fields": {
        "F0": "internal-logic",
        "F1": "Validates the structural integrity and data types of manifest files, ensuring all required fields and references are present and correctly formatted before import.",
        "F2": "Implements ValidateManifest to check required top-level fields and data integrity, and ValidateType to ensure JSON values match their schema definitions (string, number, boolean, array).",
        "F3": [
          "ValidateManifest",
          "ValidateType"
        ],
        "F4": [
          "How does the system validate manifest files before importing them?",
          "What checks are performed on the data entries in a manifest?",
          "Where is the logic that ensures manifest fields match their defined types?",
          "Why did my manifest import fail with a validation error?"
        ],
        "F5": [
          "pkg/logger"
        ],
        "F6": [
          "manifest-management",
          "stage-based-validation"
        ],
        "F7": [
          "persistence",
          "infrastructure"
        ]
      }
    },
    {
      "repo_ref": "R0",
      "branch_ref": "B0",
      "file_path": "internal/manifest/wizard.go",
      "language": "go",
      "chat_id": 6506,
      "fields": {
        "F0": "internal-logic",
        "F1": "Provides interactive CLI wizards using the survey library to guide users through creating, updating, and selecting context profiles, including Focus Scope configuration.",
        "F2": "Implements CreateProfileInteractive and UpdateProfileInteractive to prompt users for profile details (database, field, scope patterns, aliases) using survey/v2, validates inputs, and persists the configuration. Also provides SelectProfileInteractive for profile selection.",
        "F3": [
          "CreateProfileInteractive",
          "UpdateProfileInteractive",
          "SelectProfileInteractive"
        ],
        "F4": [
          "How do I create a new context profile?",
          "How do I update an existing profile's settings?",
          "Where is the interactive CLI wizard code?",
          "How do I set a Focus Scope through the wizard?"
        ],
        "F5": [
          "internal/registry",
          "internal/manifest"
        ],
        "F6": [
          "interactive-wizard",
          "focus-scope",
          "profile-based-configuration"
        ],
        "F7": [
          "discovery"
        ]
      }
    },
    {
      "repo_ref": "R0",
      "branch_ref": "B0",
      "file_path": "internal/git/discovery.go",
      "language": "go",
      "chat_id": 6508,
      "fields": {
        "F0": "pkg-util",
        "F1": "Locates the Git repository root by walking up the directory tree and retrieves tracked files using git ls-files to support scope validation and repository context.",
        "F2": "Implements FindGitRoot to traverse directories looking for .git. GetRepoContext resolves symlinks to find the physical root and relative offset. GetTrackedFiles executes git ls-files -z to get a list of tracked files, handling null-byte delimiters for safety.",
        "F3": [
          "const GitSenseDirName",
          "func FindProjectRoot() (string, error)",
          "func GetRepoContext() (root string, cwdOffset string, err error)",
          "func FindGitRoot() (string, error)",
          "func GetTrackedFiles(ctx context.Context, repoRoot string) ([]string, error)"
        ],
        "F4": [
          "How does the CLI find the .git directory?",
          "Where is the list of tracked files retrieved?",
          "How are symlinks handled in path resolution?",
          "What command is used to get repository files?"
        ],
        "F5": [
          "pkg/logger"
        ],
        "F6": [
          "git-integration",
          "focus-scope"
        ],
        "F7": [
          "infrastructure"
        ]
      }
    },
    {
      "repo_ref": "R0",
      "branch_ref": "B0",
      "file_path": "internal/git/repo_info.go",
      "language": "go",
      "chat_id": 6509,
      "fields": {
        "F0": "pkg-util",
        "F1": "Extracts repository metadata (name, URL, remote) from .git/config and provides system environment details (OS, project root).",
        "F2": "Defines RepositoryInfo and SystemInfo structs. GetRepositoryInfo parses .git/config to find the remote origin URL and derive the repo name. GetSystemInfo uses runtime and GetRepoContext to determine the OS and project root.",
        "F3": [
          "type RepositoryInfo struct",
          "type SystemInfo struct",
          "func GetRepositoryInfo() (*RepositoryInfo, error)",
          "func GetSystemInfo() (*SystemInfo, error)"
        ],
        "F4": [
          "How does the tool determine the repository name?",
          "Where is the Git remote URL parsed?",
          "How do I get the current operating system info?",
          "Where is the project root path determined?"
        ],
        "F5": [
          "internal/git/discovery.go"
        ],
        "F6": [
          "git-integration"
        ],
        "F7": [
          "infrastructure"
        ]
      }
    },
    {
      "repo_ref": "R0",
      "branch_ref": "B0",
      "file_path": "internal/db/schema.go",
      "language": "go",
      "chat_id": 6511,
      "fields": {
        "F0": "data-access",
        "F1": "Defines and initializes the SQL schema for manifest and stats databases, handling table creation, indexing, and backwards compatibility for column additions.",
        "F2": "Implements CreateSchema and CreateStatsSchema functions. Uses CREATE TABLE IF NOT EXISTS and ALTER TABLE for backwards compatibility (adding language and updated_at columns). Creates indexes for performance optimization.",
        "F3": [
          "CreateSchema",
          "CreateStatsSchema"
        ],
        "F4": [
          "How is the manifest database structured?",
          "What tables store the file metadata?",
          "How does the system handle schema updates for older databases?",
          "Where are the database indexes defined?"
        ],
        "F5": [
          "pkg/logger"
        ],
        "F6": [
          "sqlite"
        ],
        "F7": [
          "persistence",
          "infrastructure"
        ]
      }
    },
    {
      "repo_ref": "R0",
      "branch_ref": "B0",
      "file_path": "internal/db/sqlite.go",
      "language": "go",
      "chat_id": 6512,
      "fields": {
        "F0": "data-access",
        "F1": "Handles SQLite database connections using the modernc.org/sqlite driver for CGO-free execution, configuring pragmas and connection pooling for optimal CLI performance.",
        "F2": "Implements OpenDB and CloseDB. Configures Foreign Keys, WAL mode, and busy timeout. Sets connection pool limits (MaxOpenConns=1) suitable for SQLite.",
        "F3": [
          "OpenDB",
          "CloseDB"
        ],
        "F4": [
          "How do I connect to the SQLite database?",
          "What database pragmas are configured for the CLI?",
          "How are database connections managed in gsc-cli?"
        ],
        "F5": [
          "pkg/logger"
        ],
        "F6": [
          "sqlite"
        ],
        "F7": [
          "persistence",
          "infrastructure"
        ]
      }
    },
    {
      "repo_ref": "R0",
      "branch_ref": "B0",
      "file_path": "internal/cli/manifest/bundle.go",
      "language": "go",
      "chat_id": 6515,
      "fields": {
        "F0": "cli",
        "F1": "CLI command definition for generating context bundles from a manifest database using SQL queries.",
        "F2": "Defines the 'bundle' Cobra command which accepts a database name and SQL query. It delegates execution to manifest.CreateBundle and outputs the result in 'context-list' or JSON format, optimized for AI context loading.",
        "F3": [],
        "F4": [
          "How do I generate a context bundle for an AI agent?",
          "How can I execute a custom SQL query against a manifest database?",
          "What command creates a list of files with their Chat IDs?",
          "How do I export specific files based on metadata criteria?"
        ],
        "F5": [
          "internal/manifest",
          "pkg/logger"
        ],
        "F6": [
          "manifest-management",
          "sqlite"
        ],
        "F7": [
          "discovery",
          "persistence"
        ]
      }
    },
    {
      "repo_ref": "R0",
      "branch_ref": "B0",
      "file_path": "internal/cli/manifest/doctor.go",
      "language": "go",
      "chat_id": 6516,
      "fields": {
        "F0": "cli",
        "F1": "Provides a CLI command to run health checks on the `.gitsense` environment and databases, diagnosing structural issues and connectivity with optional auto-fix capabilities.",
        "F2": "Defines the doctorCmd which invokes manifest.RunDoctor with optional fix flags. It uses a local printDoctorReport helper to format the results with color-coded status icons for terminal display.",
        "F3": [],
        "F4": [
          "How do I check if my .gitsense environment is set up correctly?",
          "Command to diagnose database connectivity issues?",
          "How do I automatically fix detected gsc configuration errors?"
        ],
        "F5": [
          "internal/manifest",
          "pkg/logger"
        ],
        "F6": [
          "manifest-management"
        ],
        "F7": [
          "infrastructure"
        ]
      }
    },
    {
      "repo_ref": "R0",
      "branch_ref": "B0",
      "file_path": "internal/cli/manifest/export.go",
      "language": "go",
      "chat_id": 6517,
      "fields": {
        "F0": "cli",
        "F1": "Implements the CLI command to export manifest databases to human-readable formats (Markdown or JSON), resolving database names via the registry and handling file output.",
        "F2": "Defines the exportCmd which resolves the database name using registry.ResolveDatabase, calls manifest.ExportDatabase to generate the content, and writes the result to a file or stdout with proper error handling.",
        "F3": [],
        "F4": [
          "How do I export a manifest database to a file?",
          "Command to save manifest data as JSON or Markdown?",
          "How can I get a human-readable report of my manifest?"
        ],
        "F5": [
          "internal/manifest",
          "internal/registry",
          "pkg/logger"
        ],
        "F6": [
          "manifest-management"
        ],
        "F7": [
          "infrastructure"
        ]
      }
    },
    {
      "repo_ref": "R0",
      "branch_ref": "B0",
      "file_path": "internal/cli/manifest/flags.go",
      "language": "go",
      "chat_id": 6518,
      "fields": {
        "F0": "cli",
        "F1": "Defines shared command-line flags for manifest subcommands, such as database name and output format, to ensure consistency across the CLI interface.",
        "F2": "Provides constants for flag names and a helper function AddManifestFlags that attaches standard flags (db, format) to a cobra.Command instance using StringP for configuration.",
        "F3": [
          "FlagDBName",
          "FlagFormat",
          "AddManifestFlags"
        ],
        "F4": [
          "Where are the shared flags for manifest commands defined?",
          "How do I add the --db flag to a new manifest subcommand?",
          "What is the default output format for manifest commands?"
        ],
        "F5": [
          "github.com/spf13/cobra"
        ],
        "F6": [
          "manifest-management"
        ],
        "F7": [
          "infrastructure"
        ]
      }
    },
    {
      "repo_ref": "R0",
      "branch_ref": "B0",
      "file_path": "internal/cli/manifest/import.go",
      "language": "go",
      "chat_id": 6519,
      "fields": {
        "F0": "cli",
        "F1": "Handles user input for importing external JSON manifests into the local SQLite database system, supporting flags for naming, overwriting, and backup management.",
        "F2": "Defines a Cobra command that parses flags (name, force, no-backup), validates arguments, and delegates the heavy lifting to manifest.ImportManifest. It includes logic to prioritize database names (flag > JSON field > filename).",
        "F3": [],
        "F4": [
          "How do I load a manifest file?",
          "Import a JSON manifest into the database",
          "Update an existing manifest database",
          "Load intelligence from a file"
        ],
        "F5": [
          "internal/manifest",
          "pkg/logger"
        ],
        "F6": [
          "manifest-management",
          "atomic-import"
        ],
        "F7": [
          "persistence"
        ]
      }
    },
    {
      "repo_ref": "R0",
      "branch_ref": "B0",
      "file_path": "internal/cli/manifest/init.go",
      "language": "go",
      "chat_id": 6520,
      "fields": {
        "F0": "cli",
        "F1": "Serves as the entry point for setting up the .gitsense workspace, creating necessary directories and the initial registry file.",
        "F2": "Defines a Cobra command that invokes manifest.InitializeGitSense from the logic layer, handling success and error logging via the logger package.",
        "F3": [],
        "F4": [
          "How do I set up gsc for the first time?",
          "Initialize the GitSense workspace",
          "Create the .gitsense directory structure",
          "Prepare the project for manifest usage"
        ],
        "F5": [
          "internal/manifest",
          "pkg/logger"
        ],
        "F6": [
          "manifest-management"
        ],
        "F7": [
          "infrastructure"
        ]
      }
    },
    {
      "repo_ref": "R0",
      "branch_ref": "B0",
      "file_path": "internal/cli/manifest/list.go",
      "language": "go",
      "chat_id": 6521,
      "fields": {
        "F0": "cli",
        "F1": "Provides the user interface for querying the manifest registry to display available databases, their descriptions, tags, and entry counts.",
        "F2": "Defines a Cobra command that calls manifest.ListDatabases from the logic layer, converts the results into a generic interface slice, and uses output.FormatDatabaseTable to render the data in table, JSON, or CSV format.",
        "F3": [],
        "F4": [
          "How do I see what manifest databases are available?",
          "List all imported manifests in the workspace",
          "Show the registry of available intelligence databases",
          "What databases can I query?"
        ],
        "F5": [
          "internal/manifest",
          "internal/output"
        ],
        "F6": [
          "manifest-management"
        ],
        "F7": [
          "discovery"
        ]
      }
    },
    {
      "repo_ref": "R0",
      "branch_ref": "B0",
      "file_path": "internal/cli/manifest/root.go",
      "language": "go",
      "chat_id": 6522,
      "fields": {
        "F0": "cli",
        "F1": "Acts as the parent command for all manifest-related operations, aggregating subcommands like import, export, and list, and managing shared flags and initialization logic.",
        "F2": "Defines the root Cobra command for the 'manifest' namespace, registers all child subcommands, adds persistent flags, and includes a pre-run hook to handle the CLI Bridge code flag.",
        "F3": [
          "Cmd"
        ],
        "F4": [
          "What are the manifest commands?",
          "How do I manage manifests?",
          "List manifest subcommands"
        ],
        "F5": [
          "pkg/logger"
        ],
        "F6": [
          "manifest-management"
        ],
        "F7": [
          "infrastructure"
        ]
      }
    },
    {
      "repo_ref": "R0",
      "branch_ref": "B0",
      "file_path": "internal/cli/manifest/schema.go",
      "language": "go",
      "chat_id": 6523,
      "fields": {
        "F0": "cli",
        "F1": "Exposes the structure of manifest databases to the user, allowing inspection of available analyzers and their metadata fields through various output formats.",
        "F2": "Resolves the database name using the registry, retrieves schema information via manifest.GetSchema, and formats the output as JSON, table, or CSV using the output package utilities.",
        "F3": [],
        "F4": [
          "What fields are available in this manifest?",
          "Show me the schema for the gsc database",
          "List analyzers and their metadata types"
        ],
        "F5": [
          "internal/manifest",
          "internal/registry",
          "internal/output"
        ],
        "F6": [
          "manifest-management"
        ],
        "F7": [
          "infrastructure"
        ]
      }
    },
    {
      "repo_ref": "R0",
      "branch_ref": "B0",
      "file_path": "internal/cli/config.go",
      "language": "go",
      "chat_id": 6524,
      "fields": {
        "F0": "cli",
        "F1": "Defines the CLI interface for managing context profiles and validating focus scopes, currently hidden from the user but retained for internal logic.",
        "F2": "Implements Cobra commands for profile lifecycle (create, update, delete, use) and scope validation. Delegates logic to internal/manifest and uses survey/v2 for interactive workflows.",
        "F3": [
          "RegisterConfigCommand"
        ],
        "F4": [
          "How do I manage context profiles in the CLI?",
          "Where is the command to validate focus scope patterns?",
          "How do I switch between different workspace configurations?",
          "Is there a hidden command for profile management?",
          "How are interactive prompts handled for profile creation?"
        ],
        "F5": [
          "internal/manifest",
          "internal/git",
          "internal/output"
        ],
        "F6": [
          "focus-scope",
          "profile-based-configuration",
          "interactive-wizard"
        ],
        "F7": [
          "infrastructure",
          "discovery"
        ]
      }
    },
    {
      "repo_ref": "R0",
      "branch_ref": "B0",
      "file_path": "internal/cli/grep.go",
      "language": "go",
      "chat_id": 6525,
      "fields": {
        "F0": "cli",
        "F1": "Executes high-performance code searches using ripgrep and enriches the results with manifest metadata, allowing users to filter by semantic fields like risk or topic while viewing raw code matches.",
        "F2": "Defines the 'grep' command using Cobra. It resolves configuration and scope, executes searches via the RipgrepEngine, enriches results using the search package, and formats output for human or AI consumption. It supports the --code flag for bridge integration and records search stats asynchronously.",
        "F3": [
          "RegisterGrepCommand"
        ],
        "F4": [
          "How do I search code with metadata filters?",
          "How do I use ripgrep with the GitSense manifest?",
          "Where is the grep command defined?",
          "How do I filter search results by risk or topic?",
          "How do I send search results to the CLI Bridge?"
        ],
        "F5": [
          "internal/bridge",
          "internal/git",
          "internal/manifest",
          "internal/registry",
          "internal/search",
          "pkg/logger"
        ],
        "F6": [
          "bridge",
          "ripgrep",
          "metadata-enrichment",
          "focus-scope",
          "filter-parsing-and-validation"
        ],
        "F7": [
          "search",
          "discovery"
        ]
      }
    },
    {
      "repo_ref": "R0",
      "branch_ref": "B0",
      "file_path": "internal/cli/info.go",
      "language": "go",
      "chat_id": 6526,
      "fields": {
        "F0": "cli",
        "F1": "Displays the current workspace context, including active databases and configuration status, providing a quick overview of the environment without executing complex queries.",
        "F2": "Defines the 'info' command using Cobra. It retrieves workspace data via manifest.GetWorkspaceInfo and formats it as a table or JSON. It integrates with the bridge package to support output capture via the --code flag, stripping colors for chat compatibility.",
        "F3": [
          "RegisterInfoCommand"
        ],
        "F4": [
          "How do I see my current workspace context?",
          "What databases are currently available?",
          "Show me the project root and configuration status.",
          "How do I get workspace info in JSON format?",
          "Is my GitSense environment configured correctly?"
        ],
        "F5": [
          "internal/bridge",
          "internal/manifest",
          "pkg/logger"
        ],
        "F6": [
          "bridge",
          "manifest-management"
        ],
        "F7": [
          "discovery",
          "infrastructure"
        ]
      }
    },
    {
      "repo_ref": "R0",
      "branch_ref": "B0",
      "file_path": "internal/cli/query.go",
      "language": "go",
      "chat_id": 6527,
      "fields": {
        "F0": "cli",
        "F1": "Orchestrates metadata discovery and analysis commands, enabling users to query files by value, list available intelligence, and generate insights or coverage reports.",
        "F2": "Defines the root 'query' command and subcommands (list, insights, coverage) using Cobra. It delegates execution to the manifest package for data logic and integrates with the bridge package to support the --code flag for chat insertion. Handlers return strings to facilitate output capture.",
        "F3": [
          "RegisterQueryCommand"
        ],
        "F4": [
          "How do I list all available databases and their fields?",
          "How do I check the analysis coverage for my codebase?",
          "How do I generate an insights report for specific metadata fields?",
          "Where is the command to query files by metadata value?",
          "How do I send query results to the GitSense Chat bridge?"
        ],
        "F5": [
          "internal/bridge",
          "internal/git",
          "internal/manifest",
          "internal/registry",
          "pkg/logger"
        ],
        "F6": [
          "bridge",
          "hierarchical-discovery",
          "manifest-management",
          "focus-scope"
        ],
        "F7": [
          "discovery",
          "infrastructure"
        ]
      }
    },
    {
      "repo_ref": "R0",
      "branch_ref": "B0",
      "file_path": "internal/cli/root.go",
      "language": "go",
      "chat_id": 6528,
      "fields": {
        "F0": "cli",
        "F1": "Root command definition for the gsc CLI, registering all subcommands, managing global flags, and enforcing pre-flight workspace checks.",
        "F2": "Defines the root Cobra command and registers subcommands (manifest, query, grep, tree). Implements PersistentPreRun for log level configuration and workspace validation (Git repo and .gitsense dir checks). Handles global CLI Bridge flags and exit logic.",
        "F3": [
          "Execute",
          "HandleExit"
        ],
        "F4": [
          "Where is the main entry point for the CLI?",
          "How are global flags like verbosity handled?",
          "What pre-flight checks run before a command executes?",
          "How is the CLI Bridge code passed to subcommands?"
        ],
        "F5": [
          "internal/bridge",
          "internal/cli/manifest",
          "internal/git",
          "pkg/logger",
          "pkg/settings"
        ],
        "F6": [
          "bridge",
          "git-integration"
        ],
        "F7": [
          "infrastructure"
        ]
      }
    },
    {
      "repo_ref": "R0",
      "branch_ref": "B0",
      "file_path": "cmd/gsc/main.go",
      "language": "go",
      "chat_id": 6531,
      "fields": {
        "F0": "cli",
        "F1": "The main entry point for the gsc CLI application, responsible for initializing the command-line interface and executing the root command defined in the internal CLI layer.",
        "F2": "Initializes the application by invoking the root command execution logic from the internal CLI package and handles the exit status.",
        "F3": [
          "main"
        ],
        "F4": [
          "Where does the gsc application start?",
          "How is the root command initialized?"
        ],
        "F5": [
          "internal/cli"
        ],
        "F6": [
          "cli"
        ],
        "F7": [
          "infrastructure"
        ]
      }
    },
    {
      "repo_ref": "R0",
      "branch_ref": "B0",
      "file_path": ".gitignore",
      "language": "plaintext",
      "chat_id": 6532,
      "fields": {
        "F0": "config",
        "F1": "Specifies exclusion patterns for the Git repository to prevent build artifacts, IDE configurations, and sensitive environment data from being committed to version control.",
        "F2": "Defines glob patterns to ignore Go binaries, the .gitsense workspace directory, distribution folders, and IDE-specific files, ensuring a clean repository history.",
        "F3": [],
        "F4": [
          "What files are excluded from version control?",
          "Why is the .gitsense directory ignored by Git?",
          "Where are build artifacts and binary outputs defined?",
          "How are IDE-specific files handled in this repository?"
        ],
        "F5": [],
        "F6": [
          "git-integration"
        ],
        "F7": [
          "infrastructure"
        ]
      }
    },
    {
      "repo_ref": "R0",
      "branch_ref": "B0",
      "file_path": "go.sum",
      "language": "plaintext",
      "chat_id": 6534,
      "fields": {
        "F0": "config",
        "F1": "Locks the cryptographic hashes of all Go module dependencies to ensure reproducible and secure builds for the project.",
        "F2": "Stores SHA256 checksums for all direct and indirect dependencies listed in go.mod, allowing the Go toolchain to verify the integrity of downloaded modules and ensuring that every build uses identical code.",
        "F3": [],
        "F4": [
          "What are the exact versions of the dependencies used?",
          "How is build reproducibility ensured?",
          "What are the checksums for the project's libraries?",
          "Is the dependency tree secure?",
          "What specific commit hashes are locked for the modules?"
        ],
        "F5": [
          "go.mod"
        ],
        "F6": [],
        "F7": [
          "infrastructure"
        ]
      }
    },
    {
      "repo_ref": "R0",
      "branch_ref": "B0",
      "file_path": "Makefile",
      "language": "plaintext",
      "chat_id": 6535,
      "fields": {
        "F0": "config",
        "F1": "Automates the build, installation, testing, and cross-compilation processes for the gsc-cli binary, streamlining development and deployment workflows.",
        "F2": "Defines Make targets for compiling the Go application from ./cmd/gsc, managing dependencies via go mod, and generating cross-platform binaries for Linux, macOS, and Windows using GOOS and GOARCH environment variables.",
        "F3": [],
        "F4": [
          "How do I build the gsc-cli binary?",
          "How do I run the test suite?",
          "How do I create a release build for Linux or macOS?",
          "How do I clean build artifacts?",
          "How do I install the tool locally?"
        ],
        "F5": [
          "cmd/gsc"
        ],
        "F6": [],
        "F7": [
          "infrastructure"
        ]
      }
    },
    {
      "repo_ref": "R0",
      "branch_ref": "B0",
      "file_path": "internal/search/filter_parser.go",
      "language": "go",
      "chat_id": 6554,
      "fields": {
        "F0": "internal-logic",
        "F1": "Parses user-provided filter strings into structured SQL WHERE clauses, handling operator validation, type checking, and range syntax to enable metadata-driven search.",
        "F2": "Implements ParseFilters to validate syntax and operators against the manifest schema. Supports range queries, standard operators, and existence checks. Generates parameterized SQL fragments for safe execution against SQLite.",
        "F3": [
          "ParseFilters",
          "BuildSQLWhereClause",
          "FilterCondition"
        ],
        "F4": [
          "How are user filter strings converted into SQL queries?",
          "Where is the logic for validating filter operators against field types?",
          "How does the search system handle range queries like 0..10?",
          "What generates the WHERE clause for metadata filtering?"
        ],
        "F5": [
          "internal/manifest",
          "internal/search/models"
        ],
        "F6": [
          "filter-parsing-and-validation",
          "sqlite"
        ],
        "F7": [
          "search",
          "infrastructure"
        ]
      }
    },
    {
      "repo_ref": "R0",
      "branch_ref": "B0",
      "file_path": "internal/search/stats.go",
      "language": "go",
      "chat_id": 6555,
      "fields": {
        "F0": "internal-logic",
        "F1": "Persists search execution metadata (patterns, duration, matches) to a local SQLite database to enable analytics and power the future Scout intelligence feature.",
        "F2": "RecordSearch resolves the stats DB path, opens a connection using db.OpenDB, ensures the search_history schema exists, and inserts the record. It handles errors gracefully by logging warnings without failing the search operation.",
        "F3": [
          "RecordSearch"
        ],
        "F4": [
          "How does gsc track search history for analytics?",
          "Where is the search statistics database stored?",
          "What metadata is recorded when I run a search?",
          "How does the Scout feature access historical search data?"
        ],
        "F5": [
          "internal/db",
          "internal/git",
          "pkg/logger",
          "pkg/settings"
        ],
        "F6": [
          "sqlite"
        ],
        "F7": [
          "persistence",
          "infrastructure"
        ]
      }
    },
    {
      "repo_ref": "R0",
      "branch_ref": "B0",
      "file_path": "internal/registry/resolver.go",
      "language": "go",
      "chat_id": 6586,
      "fields": {
        "F0": "data-access",
        "F1": "Resolves user-provided database identifiers to canonical physical names, handling sanitization and case-insensitive matching.",
        "F2": "Implements ResolveDatabase which loads the registry, sanitizes input (stripping extensions), and performs exact or case-insensitive lookups against DatabaseName and ManifestName.",
        "F3": [
          "ResolveDatabase",
          "sanitizeInput"
        ],
        "F4": [
          "How does gsc resolve database names?",
          "Can I use the display name to select a database?",
          "How are database extensions handled in commands?",
          "Where is the registry lookup logic implemented?"
        ],
        "F5": [
          "internal/registry"
        ],
        "F6": [
          "manifest-management"
        ],
        "F7": [
          "persistence"
        ]
      }
    },
    {
      "repo_ref": "R0",
      "branch_ref": "B0",
      "file_path": "internal/manifest/gitsense_map.go",
      "language": "go",
      "chat_id": 6602,
      "fields": {
        "F0": "internal-logic",
        "F1": "Loads and validates the project-level .gitsense-map file, which defines version-controlled team defaults for Focus Scope configuration.",
        "F2": "Locates the .gitsense-map file at the repository root, parses its JSON content into a GitSenseMap struct, converts it to a ScopeConfig, and performs basic structural validation of the defined patterns.",
        "F3": [
          "GitSenseMap",
          "LoadGitSenseMap",
          "ValidateGitSenseMap"
        ],
        "F4": [
          "How do I define a default scope for the entire team?",
          "Where is the .gitsense-map file loaded?",
          "How does the system read project-level configuration?",
          "What is the structure of the .gitsense-map file?"
        ],
        "F5": [
          "internal/git",
          "pkg/logger"
        ],
        "F6": [
          "focus-scope"
        ],
        "F7": [
          "discovery"
        ]
      }
    },
    {
      "repo_ref": "R0",
      "branch_ref": "B0",
      "file_path": "internal/manifest/scope.go",
      "language": "go",
      "chat_id": 6603,
      "fields": {
        "F0": "internal-logic",
        "F1": "Implements the core logic for Focus Scope, including glob-based file filtering, pattern validation with Levenshtein suggestions, and the precedence chain for resolving active scopes.",
        "F2": "Defines the ScopeConfig struct and provides functions to parse string overrides, match file paths using doublestar globs, validate patterns against tracked files, and resolve the active scope based on a strict precedence chain (CLI > Profile > Project Map > Default).",
        "F3": [
          "ScopeConfig",
          "ParseScopeOverride",
          "MatchScope",
          "ValidateScope",
          "ResolveScopeForQuery"
        ],
        "F4": [
          "How does gsc determine which files are in scope?",
          "What is the order of precedence for Focus Scope configuration?",
          "How are glob patterns validated against the repository?",
          "Where is the logic for matching file paths to scope rules?"
        ],
        "F5": [
          "internal/git",
          "pkg/logger"
        ],
        "F6": [
          "focus-scope",
          "scope-resolution-precedence"
        ],
        "F7": [
          "discovery"
        ]
      }
    },
    {
      "repo_ref": "R0",
      "branch_ref": "B0",
      "file_path": "internal/manifest/importer_test.go",
      "language": "go",
      "chat_id": 6630,
      "fields": {
        "F0": "internal-logic",
        "F1": "Unit tests for the manifest importer, validating atomic import workflows, backup rotation logic, registry upserts, and file compression utilities.",
        "F2": "Contains test cases for the atomic import process, backup rotation limits, registry entry upserts, and file compression. Uses temporary directory setups to simulate the .gitsense environment.",
        "F3": [],
        "F4": [
          "How is the atomic import process tested?",
          "What tests exist for backup rotation logic?",
          "How are registry upserts validated?",
          "Is there test coverage for file compression utilities?",
          "How does the test environment simulate the .gitsense directory?"
        ],
        "F5": [
          "internal/registry",
          "pkg/settings"
        ],
        "F6": [
          "atomic-import",
          "manifest-management"
        ],
        "F7": [
          "persistence"
        ]
      }
    },
    {
      "repo_ref": "R0",
      "branch_ref": "B0",
      "file_path": "internal/bridge/bridge.go",
      "language": "go",
      "chat_id": 6867,
      "fields": {
        "F0": "internal-logic",
        "F1": "Orchestrates the CLI Bridge lifecycle, managing handshake validation, status updates, user confirmation, and the insertion of command output into the GitSense Chat database.",
        "F2": "Implements Execute to run the bridge flow. Uses ValidateCode for stage-based checks (Discovery, Execution, Insertion). Handles signal interruption (SIGINT). Performs atomic file updates for handshake status. Inserts messages into SQLite via db package.",
        "F3": [
          "Execute",
          "ValidateCode",
          "LoadHandshake",
          "UpdateStatus",
          "InsertToChat"
        ],
        "F4": [
          "How does the CLI Bridge insert messages into the chat?",
          "What happens if the bridge output is too large?",
          "How are bridge codes validated against expiration?",
          "Where is the handshake lifecycle managed?",
          "How does the bridge handle user interruption (Ctrl+C)?"
        ],
        "F5": [
          "internal/db",
          "internal/output",
          "pkg/logger",
          "pkg/settings"
        ],
        "F6": [
          "bridge",
          "stage-based-validation"
        ],
        "F7": [
          "infrastructure",
          "integration"
        ]
      }
    },
    {
      "repo_ref": "R0",
      "branch_ref": "B0",
      "file_path": "internal/db/chats.go",
      "language": "go",
      "chat_id": 6868,
      "fields": {
        "F0": "data-access",
        "F1": "Library methods for interacting with the GitSense Chat database, including message insertion and validation.",
        "F2": "Implements GetMessage, IsLeafNode, and InsertMessage. Uses SQL queries to check for children (leaf node validation) and inserts messages with automatic model resolution via subquery.",
        "F3": [
          "GetMessage",
          "IsLeafNode",
          "InsertMessage"
        ],
        "F4": [
          "How do I insert a message into the chat database?",
          "How does the system check if a message is a leaf node?",
          "Where is the logic for retrieving chat history?"
        ],
        "F5": [
          "internal/db/models.go"
        ],
        "F6": [
          "sqlite",
          "bridge"
        ],
        "F7": [
          "persistence"
        ]
      }
    },
    {
      "repo_ref": "R0",
      "branch_ref": "B0",
      "file_path": "internal/db/models.go",
      "language": "go",
      "chat_id": 6869,
      "fields": {
        "F0": "data-access",
        "F1": "Defines the Go structs that map to the GitSense Chat SQLite schema (chats and messages tables).",
        "F2": "Defines Chat and Message structs using sql.Null types for nullable database fields, mirroring the chats and messages tables.",
        "F3": [
          "Chat",
          "Message"
        ],
        "F4": [
          "What is the data structure for a chat message?",
          "How are the database tables modeled in Go?",
          "Where are the Chat and Message types defined?"
        ],
        "F5": [],
        "F6": [
          "sqlite"
        ],
        "F7": [
          "persistence"
        ]
      }
    },
    {
      "repo_ref": "R0",
      "branch_ref": "B0",
      "file_path": "internal/cli/tree.go",
      "language": "go",
      "chat_id": 6953,
      "fields": {
        "F0": "cli",
        "F1": "CLI command definition for 'gsc tree', handling user input, coordinating tree construction and enrichment, and managing output formatting and CLI Bridge integration.",
        "F2": "Orchestrates the tree visualization workflow by fetching Git tracked files, building a tree structure, resolving the database, and performing batch metadata enrichment. Supports human, JSON, and AI-portable rendering, plus CLI Bridge integration.",
        "F3": [
          "RegisterTreeCommand"
        ],
        "F4": [
          "How do I visualize the repository structure with metadata?",
          "How do I generate an AI-portable project map?",
          "What command shows me the analysis coverage of my codebase?",
          "How do I send a file tree to a GitSense Chat session?"
        ],
        "F5": [
          "internal/bridge",
          "internal/git",
          "internal/manifest",
          "internal/registry",
          "internal/search",
          "internal/tree",
          "pkg/logger"
        ],
        "F6": [
          "tree-visualization",
          "metadata-enrichment",
          "bridge",
          "git-integration"
        ],
        "F7": [
          "discovery",
          "infrastructure"
        ]
      }
    },
    {
      "repo_ref": "R0",
      "branch_ref": "B0",
      "file_path": "internal/tree/tree.go",
      "language": "go",
      "chat_id": 6955,
      "fields": {
        "F0": "internal-logic",
        "F1": "Core logic for building, enriching, pruning, and rendering hierarchical filesystem trees with metadata coverage statistics.",
        "F2": "Implements recursive algorithms to construct filesystem trees from flat file lists, enrich nodes with metadata from the search subsystem, and calculate coverage statistics. Supports rendering in ASCII, standard JSON, and AI-Portable JSON formats.",
        "F3": [
          "BuildTree",
          "EnrichTree",
          "PruneTree",
          "CalculateStats",
          "RenderHuman",
          "RenderJSON",
          "RenderPortableJSON",
          "Node",
          "TreeStats",
          "PortableNode"
        ],
        "F4": [
          "How does the tree command calculate analysis coverage percentages?",
          "Where is the logic for rendering the ASCII tree structure?",
          "How are files pruned from the tree if they lack metadata?",
          "What is the structure of the AI-Portable JSON output?",
          "How does the tree builder handle relative paths from the current working directory?"
        ],
        "F5": [
          "internal/search"
        ],
        "F6": [
          "tree-visualization",
          "metadata-enrichment"
        ],
        "F7": [
          "discovery",
          "infrastructure"
        ]
      }
    },
    {
      "repo_ref": "R0",
      "branch_ref": "B0",
      "file_path": "internal/manifest/deleter.go",
      "language": "go",
      "chat_id": 7018,
      "fields": {
        "F0": "internal-logic",
        "F1": "Orchestrates the deletion of manifest databases, ensuring both the physical file and the registry entry are removed atomically.",
        "F2": "Loads the registry to verify existence, resolves the database path, deletes the physical SQLite file, updates the registry by removing the entry, and persists the changes.",
        "F3": [
          "DeleteManifest"
        ],
        "F4": [
          "How do I delete a manifest database?",
          "Where is the logic for removing database files?",
          "Does deleting a manifest update the registry?",
          "How are orphaned database files handled?",
          "What happens when I delete a database that is already missing from disk?"
        ],
        "F5": [
          "internal/registry",
          "pkg/logger"
        ],
        "F6": [
          "manifest-management"
        ],
        "F7": [
          "persistence"
        ]
      }
    },
    {
      "repo_ref": "R0",
      "branch_ref": "B0",
      "file_path": "internal/cli/manifest/delete.go",
      "language": "go",
      "chat_id": 7019,
      "fields": {
        "F0": "cli",
        "F1": "Provides the CLI interface for removing manifest databases, handling user input and delegating file deletion and registry updates to the internal logic layer.",
        "F2": "Defines a Cobra command that accepts a database name argument, invokes the manifest.DeleteManifest function to remove the physical file and update the registry, and returns success or error messages.",
        "F3": [],
        "F4": [
          "How do I delete a manifest database?",
          "Remove a specific manifest from the workspace",
          "Clean up old manifest files"
        ],
        "F5": [
          "internal/manifest"
        ],
        "F6": [
          "manifest-management"
        ],
        "F7": [
          "infrastructure"
        ]
      }
    }
  ]
}
