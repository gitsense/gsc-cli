# GitSense Chat CLI (`gsc`)

**The Intelligence Layer for Codebase Discovery and Agent Orchestration.**

GitSense Chat CLI (`gsc`) is a command-line tool that manages intelligence derived from GitSense Chat Brains. It transforms your codebase into a queryable intelligence hub, enabling AI agents and developers to interact with structured metadata extracted from code repositories.

## The Problem: Blind Discovery

AI agents and developers face a scalability problem when navigating large codebases. Traditional tools like `grep` or `ripgrep` are syntax-based and "dumb": they only understand patterns, not purpose.

For AI agents, this can result in "context blindness," where they can ingest thousands of irrelevant tokens (tests, docs, dead code) just to find the small percentage of code that matters. For developers, it can make understanding business impact, risk, and ownership difficult without manual investigation.

## The Solution: The Intelligence Layer

`gsc` is a metadata orchestration layer that sits between raw code and the consumer. It combines pattern matching with domain-specific intelligence generated by [GitSense Chat](https://github.com/gitsense/chat).

### The Intelligence Supply Chain

`gsc` acts as the local execution engine for intelligence created through the GitSense ecosystem:

1.  **Create Brains (GitSense Chat):** Domain experts define Analyzers (Brains) in the GitSense Chat web app to encode business logic, security risks, or architectural dependencies.
2.  **Analyze at Scale (GitSense Chat):** The web app deploys these Brains against repositories to generate raw metadata.
3.  **Curate and Download:** Once analysis is complete, users can curate this intelligence into focused Metadata Manifests (JSON) based on their specific needs.
4.  **Portable Intelligence:** Downloaded manifests are self-contained JSON files that can be used anywhere.
5.  **Import Intelligence (`gsc`):** `gsc manifest import` converts a manifest into a local database.
6.  **Discover and Search (`gsc`):** Agents and developers use `gsc query` to explore the "Map" of the codebase and `gsc grep` to search the "Territory" using metadata filters.

## Core Pillars

### 1. `gsc query`: Metadata-First Discovery
Before searching for code, you need to understand the landscape. `gsc query` allows you to analyze the metadata distribution of your codebase without reading source code. It helps agents identify which databases, fields, and values are relevant to their current task via subcommands like `list`, `insights`, and `coverage`.

### 2. `gsc grep`: Enriched Pattern Matching
`gsc grep` provides high-speed search (powered by `ripgrep`) that is enriched with metadata in real-time. This allows for semantic filtering (e.g., `topic=security`) that can prune results before they are ever sent to an LLM.

### 3. The Two-Phase Agent Workflow
`gsc` introduces a decision gate that can significantly reduce agent token consumption:
*   **Phase 1: The Scout (`--summary`):** The agent runs a cheap query to see the metadata distribution.
*   **Phase 2: The Surgeon (`--filter`):** The agent applies metadata filters to retrieve only matching lines and context lines for high-signal files.

## Installation

[Placeholder: Installation instructions will be provided once `gsc` is available on GitHub.]

## Quick Start

### 1. Initialize the Workspace
```bash
gsc manifest init
```

### 2. Download a Manifest
[Placeholder: Instructions on how to download a manifest via the GitSense Chat app.]

### 3. Import Intelligence
```bash
gsc manifest import path/to/manifest.json
```

### 4. Set and Clear Context
**Available Commands:**
*   `gsc config context create <name>`: Create a new profile.
*   `gsc config use <name>`: Activate a profile.
*   `gsc config clear`: Deactivate the current profile.
*   `gsc config active`: Show the currently active profile.

### 5. Discover (The Map)
```bash
# List available metadata fields in the active database
gsc query list

# See unique values for a specific field
gsc query list risk_level

# Analyze metadata distribution
gsc query insights --field risk_level --report

# Check analysis coverage
gsc query coverage
```

### 6. Search (The Territory)
```bash
# Get a summary of matches to understand the landscape
gsc grep "validate" --summary

# Execute a targeted search using metadata filters
gsc grep "validate" --filter "topic=security" --filter "risk_level=critical"
```

## Commands

### `gsc manifest`
Management of the local intelligence hub.
*   `init`: Initialize the `.gitsense` directory.
*   `import <file>`: Import a JSON manifest into a local database.
*   `list`: List available databases.
*   `schema <db>`: Inspect analyzers and fields within a database.

### `gsc query`
Discovery of metadata and file relationships.
*   `list [field]`: Discover available databases (`--dbs`), fields, or values.
*   `insights`: Analyze metadata distribution (requires `--field`).
*   `coverage`: Analyze analysis coverage and identify blind spots.
*   `--value <val>`: Match a specific metadata value (top-level query).

### `gsc grep`
Search with metadata enrichment.
*   `--summary`: Return only aggregated metadata (cheap, fast).
*   `--filter "field=value"`: Filter results by metadata fields.
*   `--analyzed [true|false]`: Filter by analysis status.

### `gsc config`
Management of context profiles and workspace settings.
*   `use <profile>`: Activate a context profile.
*   `context create <name>`: Create a new profile.
*   `clear`: Deactivate the current profile.

### `gsc info`
Display current workspace context, active profile, and database status.

## Architecture
`gsc` is built on a modular architecture designed for performance and tool-agnosticism.

## Roadmap

### `gsc scout`
An automated orchestrator that translates natural language intent into multi-phase `query` and `grep` loops.

### `gsc ls`
An enhanced filesystem listing command that brings domain-specific intelligence to the command line.

## Requirements
*   **Ripgrep:** Required in PATH for search functionality.
*   **Git:** Required for repository info and finding the project root.
