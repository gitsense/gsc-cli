# GitSense Chat CLI (`gsc`)

**The Intelligence Layer for Codebase Discovery and Agent Orchestration.**

GitSense Chat CLI (`gsc`) is a command-line tool that manages intelligence derived from GitSense Chat Brains. It transforms your codebase into a queryable intelligence hub, enabling AI agents and developers to interact with structured metadata extracted from code repositories.

## The Problem: Blind Discovery

AI agents and developers face a scalability problem when navigating large codebases. Traditional tools like `grep` or `ripgrep` are syntax-based and "dumb": they only understand patterns, not purpose.

For AI agents, this can result in "context blindness," where they can ingest thousands of irrelevant tokens (tests, docs, dead code) just to find the small percentage of code that matters. For developers, it can make understanding business impact, risk, and ownership difficult without manual investigation.

## The Solution: The Intelligence Layer

`gsc` is a metadata orchestration layer that sits between raw code and the consumer. It combines pattern matching with domain-specific intelligence generated by [GitSense Chat](https://github.com/gitsense/chat).

### The Intelligence Supply Chain

`gsc` acts as the local execution engine for intelligence created through the GitSense ecosystem:

1.  **Create Brains (GitSense Chat):** Domain experts define Analyzers (Brains) in the GitSense Chat web app to encode business logic, security risks, or architectural dependencies.
2.  **Analyze at Scale (GitSense Chat):** The web app deploys these Brains against repositories to generate raw metadata.
3.  **Curate and Download:** Once analysis is complete, users can curate this intelligence into focused Metadata Manifests (JSON) based on their specific needs. Whether you need a security-centric view or a map of merged pull requests, you curate the data you want and download it. This "no-lock-in" approach ensures you own the intelligence derived from your code.
4.  **Portable Intelligence:** Downloaded manifests are self-contained JSON files that can be used anywhere. Deploy them to sandboxed environments, air-gapped networks, or local development machines. This portability enables coding agents to operate with domain-specific intelligence without requiring cloud connectivity or external dependencies.
5.  **Import Intelligence (`gsc`):** `gsc manifest import` converts a manifest into a local database. This creates a portable, queryable Intelligence Hub.
6.  **Discover and Search (`gsc`):** Agents and developers use `gsc query` to explore the "Map" of the codebase and `gsc grep` to search the "Territory" using metadata filters.

## Core Pillars

### 1. `gsc query`: Metadata-First Discovery
Before searching for code, you need to understand the landscape. `gsc query` allows you to analyze the metadata distribution of your codebase without reading source code. It helps agents identify which databases, fields, and values are relevant to their current task.

### 2. `gsc grep`: Enriched Pattern Matching
`gsc grep` provides high-speed search (powered by `ripgrep`) that is enriched with metadata in real-time. This allows for semantic filtering (e.g., `topic=security`) that can prune results before they are ever sent to an LLM.

### 3. The Two-Phase Agent Workflow
`gsc` introduces a decision gate that can significantly reduce agent token consumption:
*   **Phase 1: The Scout (`--summary`):** The agent runs a cheap query to see the metadata distribution. For example, if `gsc grep fix --summary` matches many files but none have a `security purpose`, the agent can decide to stop or refine the search.
*   **Phase 2: The Surgeon (`--filter`):** The agent applies metadata filters to retrieve only matching lines and context lines for high-signal files. For example, `gsc grep "fix" --filter "topic in (security, auth)"`

## Installation

[Placeholder: Installation instructions will be provided once `gsc` is available on GitHub.]

## Quick Start

### 1. Initialize the Workspace
```bash
gsc manifest init
```
This command creates a `.gitsense` directory in your project root. This directory serves as your local **Intelligence Hub** for your repository, where all GitSense data is stored.

### 2. Download a Manifest
[Placeholder: Instructions on how to download a manifest via the GitSense Chat app or review an example manifest will be provided here.]

### 3. Import Intelligence
Import a manifest generated by GitSense Chat to create your local Intelligence Hub.

```bash
gsc manifest import path/to/manifest.json
```

### 4. Set and Clear Context

In `gsc`, a **Context** (managed via Profiles) is your active workspace configuration. It allows you to switch between different "Brains" (databases) and save your preferred settings so you don't have to type them repeatedly.

**The Interactive Wizard**

You don't need to memorize command-line flags to create or update contexts. `gsc` provides an **Interactive Wizard** that guides you through the setup process.


**Available Commands:**
*   `gsc config context create <name>`: Create a new profile (launches wizard if flags are missing).
*   `gsc config context update <name>`: Update an existing profile (launches wizard if flags are missing).
*   `gsc config use <name>`: Activate a profile (interactive menu if no name provided).
*   `gsc config clear`: Deactivate the current profile.
*   `gsc config active`: Show the currently active profile.

### 5. Discover (The Map)
```bash
# List available metadata fields in the active database
gsc query --list

# See unique values for a specific field
gsc query --field risk_level --list
```

### 6. Search (The Territory)
```bash
# Get a summary of matches to understand the landscape
gsc grep "validate" --summary

# Execute a targeted search using metadata filters
gsc grep "validate" --filter "topic=security" --filter "risk_level=critical"
```

## Commands

### `gsc manifest`
Management of the local intelligence hub.
*   `init`: Initialize the `.gitsense` directory.
*   `import <file>`: Import a JSON manifest into a local database.
*   `list`: List available databases.
*   `schema <db>`: Inspect analyzers and fields within a database.
*   `export <db>`: Export a database to Markdown or JSON.

### `gsc query`
Discovery of metadata and file relationships.
*   `--list-db`: List all available databases.
*   `--list`: List fields in the active database.
*   `--field <name>`: Specify a field to query or list.
*   `--value <val>`: Match a specific metadata value.

### `gsc grep`
Search with metadata enrichment.
*   `--summary`: Return only aggregated metadata (cheap, fast).
*   `--filter "field=value"`: Filter results by metadata fields.
*   `--analyzed [true|false]`: Filter by analysis status.

### `gsc config`
Management of context profiles and workspace settings.
*   `use <profile>`: Activate a context profile (e.g., security, payments).
*   `context create <name>`: Create a new profile.
*   `context update <name>`: Update an existing profile.
*   `clear`: Deactivate the current profile.
*   `active`: Show the currently active profile.

### `gsc info`
Display current workspace context, active profile, and database status.

## Architecture

`gsc` is built on a modular architecture designed for performance and tool-agnosticism:
*   **Search Engine Interface:** Abstracts the search tool. Currently uses `ripgrep`, with support for `git grep` planned.
*   **Enricher:** Joins raw search results with local database metadata.
*   **Filter Parser:** Parses filter syntax (e.g., `topic=security`, `complexity=0..10`) into database queries.
*   **Stats Recorder:** Logs search execution to power future analytics and `scout` optimization.

## Roadmap

### `gsc scout`
An automated orchestrator that translates natural language intent into multi-phase `query` and `grep` loops. `gsc scout` does not replace coding agents; it makes them smarter. By outsourcing the file discovery process to `gsc scout`, coding agents can leverage the domain knowledge encoded in Brains (such as business logic or security expertise) to find the right files more effectively. This can significantly reduce coding agent time and improve success rates.

### `gsc ls`
An enhanced filesystem listing command that brings domain-specific intelligence to the command line. It allows you to access any knowledge derived from your Brains directly when viewing files. Whether you need to see merged pull requests, ownership details, risk levels, or custom business logic, `gsc ls` transforms the filesystem into a dashboard of curated knowledge, making abstract metadata instantly visible for both humans and AI agents.

## Requirements
*   **Ripgrep:** Required in PATH for search functionality.
*   **Git:** Required for repository info and finding the project root.

## Contributing
GitSense Chat CLI is an open source project. We welcome contributions that improve the intelligence layer or add new search engine implementations.

## License
[Your License Here]
